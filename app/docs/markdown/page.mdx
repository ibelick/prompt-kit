import ComponentCodePreview from "@/components/app/component-code-preview"
import { generateMetadata } from "../utils/metadata"
import { MarkdownBasic } from "./markdown-basic"
import { MarkdownCustomComponents } from "./markdown-custom-components"

export const metadata = generateMetadata(
  "Markdown",
  "A component for rendering Markdown content with support for GitHub Flavored Markdown (GFM) and custom component styling."
)

# Markdown

A component for rendering Markdown content with support for GitHub Flavored Markdown (GFM) and custom component styling. Uses [Streamdown](https://streamdown.ai/) under the hood, a high-performance Markdown renderer built specifically for streaming AI responses.

## Key features

- **Unterminated Markdown parsing** - Handles incomplete syntax during streaming
- **Advanced memoization** - Only re-renders changed blocks for optimal performance
- **Interactive controls** - Copy, download, and fullscreen actions for code, tables, and diagrams
- **CJK language support** - Proper emphasis handling for Chinese, Japanese, and Korean
- **Security hardening** - Built-in sanitization to protect against malicious content
- **GFM support** - Tables, task lists, strikethrough, and autolinks
- **Mathematics** - LaTeX rendering via KaTeX
- **Mermaid diagrams** - Interactive diagram rendering with controls
- **200+ languages** - Syntax highlighting powered by Shiki

## Examples

### Basic Markdown

Render basic Markdown with support for bold, italics, lists, code blocks and more.

<ComponentCodePreview
  component={<MarkdownBasic />}
  filePath="app/docs/markdown/markdown-basic.tsx"
  classNameComponentContainer="p-8"
  disableNotProse
/>

### Markdown with Custom Components

You can customize how different Markdown elements are rendered by providing custom components.

<ComponentCodePreview
  component={<MarkdownCustomComponents />}
  filePath="app/docs/markdown/markdown-custom-components.tsx"
  classNameComponentContainer="p-8"
/>

## Installation

<Tabs defaultValue="cli">

<TabsList>
  <TabsTrigger value="cli">CLI</TabsTrigger>
  <TabsTrigger value="manual">Manual</TabsTrigger>
</TabsList>

<TabsContent value="cli">

First, install the component using the CLI:

<CodeBlock
  code={`npx shadcn add "https://prompt-kit.com/c/markdown.json"`}
  language="bash"
/>

Then, reference the necessary CSS file to load the default styles for Streamdown.

### Tailwind v4

Add the following CSS source directive to your globals.css or main CSS file:

<CodeBlock language="css" code={`@source "../node_modules/streamdown/dist/*.js";`} />

### Tailwind v3

Add Streamdown to your content array in your tailwind.config.js:

<CodeBlock language="js" code={`module.exports = {
    content: [
        './node_modules/streamdown/dist/**/*.js',
    ],
    // ... rest of your config
}`} />

Make sure the path matches the location of your node_modules folder relative to your CSS file.

</TabsContent>

<TabsContent value="manual">

<Steps>

<Step>Copy and paste the following code into your project.</Step>

<CodeBlock filePath="components/prompt-kit/markdown.tsx" language="tsx" />

<Step>Install the required dependencies.</Step>

<CodeBlock
  code={`npm install streamdown`}
  language="bash"
/>

<Step>Update the import paths to match your project setup.</Step>

<Step>
Reference the necessary CSS file to load the default styles for Streamdown.

If you're using Tailwind v4, add the following CSS source directive to your globals.css or main CSS file:

<CodeBlock language="css" code={`@source "../node_modules/streamdown/dist/*.js";`} />

If you're using Tailwind v3, add Streamdown to your content array in your tailwind.config.js:

<CodeBlock language="js" code={`module.exports = {
    content: [
        './node_modules/streamdown/dist/**/*.js',
    ],
    // ... rest of your config
}`} />

Make sure the path matches the location of your node_modules folder relative to your CSS file.
</Step>

</Steps>

</TabsContent>

</Tabs>

## Component API

### Markdown

| Prop       | Type                                         | Default            | Description                                     |
| :--------- | :------------------------------------------- | :----------------- | :---------------------------------------------- |
| children   | string                                       |                    | Markdown content to render                      |
| className  | string                                       |                    | Additional CSS classes                          |
| ...props   | `React.ComponentProps<typeof Streamdown>`    |                    | All other Streamdown props                      |

## Unterminated Markdown Parsing

One of the Markdown component's most powerful features is its ability to handle incomplete Markdown syntax during streaming. Traditional Markdown parsers fail when encountering partial syntax like `**unclosed bold` or `` `incomplete code``, but Streamdown intelligently detects these patterns and auto-completes them for proper rendering.

When the actual closing syntax arrives in the stream, Streamdown seamlessly transitions to the complete version without visual disruption. This solves a critical UX problem in AI chat interfaces where responses are streamed token-by-token.

<CodeBlock
  code={`// These incomplete patterns render correctly during streaming:
**bold text...          → auto-closed and rendered
\`inline code...        → auto-closed and rendered
> blockquote...         → continues properly
- list item...          → formatted correctly`}
  language="sh"
/>

The parser also preserves word-internal characters like underscores in variable names (e.g., `my_variable_name`) by distinguishing between inline and block-level patterns.

## Performance Optimization

The Markdown component employs advanced memoization techniques to optimize rendering performance, especially in streaming AI response scenarios. This approach is crucial when rendering chat interfaces where new tokens are continuously streamed.

### How Memoization Works

Our implementation:

1. Splits Markdown content into discrete semantic blocks using the `marked` library
2. Memoizes each block individually with React's `memo`
3. Only re-renders blocks that have actually changed when new content arrives
4. Preserves already rendered blocks to prevent unnecessary re-parsing and re-rendering

This pattern significantly improves performance in chat applications by preventing the entire message history from re-rendering with each new token, which becomes increasingly important as conversations grow longer.

<CodeBlock
  code={`<Markdown>{message.content}</Markdown>`}
  language="tsx"
/>

### Interactive Controls During Streaming

The component automatically disables interactive controls (copy buttons, downloads) during active streaming via the `isAnimating` prop. This prevents users from accidentally copying incomplete code or content mid-generation.

## Security Hardening

Streamdown includes built-in security sanitization via `rehype-harden` to protect against malicious content in AI-generated responses. The default configuration allows all links and images, but you can restrict this for untrusted sources:

<CodeBlock code={`// Restrict to specific domains
const secureComponents = {
    allowedDomains: ['trusted-domain.com', 'cdn.example.com'],
    disableDataImages: true # Prevent base64 tracking pixels
}

<Markdown rehypeHarden={secureComponents}>{content}</Markdown>
`} language="tsx" />

This is especially important for protecting against prompt injection attacks and tracking pixels in user-generated or AI-generated content.

## Customizing Components

You can customize how different Markdown elements are rendered by providing a `components` prop. This is an object where keys are HTML element names and values are React components.

<CodeBlock code={`const customComponents = {
    h1: ({ children }) => <h1 className="text-2xl font-bold text-blue-500">{children}</h1>,
    a: ({ href, children }) => <a href={href} className="text-purple-500 underline">{children}</a>,
    // ... other components
}

<Markdown components={customComponents}>{markdownContent}</Markdown>
`} language="tsx" />

You can also use CSS variables and `data-streamdown` attribute selectors for theming without component overrides.
